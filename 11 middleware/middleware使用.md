# 1 声明中间件使用的范围
## 1.1 局部,基于@server
```go
@server(
	// jwt:   Auth
	group: foo
	prefix: userapi/v1
	middleware: TestMiddleware
	
)
```
## 1.2 全局
### 1.2.1 定义一个全局中间件
在一个单独的文件夹中,如项目根目录下common/middleware下面:
```go
package middleware

import (
	"fmt"
	"net/http"
)

type GlobalMiddleware struct {

}

func NewGlobalMiddleware() *GlobalMiddleware {
	return &GlobalMiddleware{}
}

func (m *GlobalMiddleware) Handle(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// before
		fmt.Println("[+] before.")
		
		next(w,r)
		
		// after
		fmt.Println("[+] after.")
	}
}
```
### 1.2.2 在main函数申明使用全局中间件
```go
func main() {
	flag.Parse()

	var c config.Config
	conf.MustLoad(*configFile, &c)

	ctx := svc.NewServiceContext(c)
	server := rest.MustNewServer(c.RestConf)
	defer server.Stop()

	// 使用全局中间件
	server.Use(middleware.NewGlobalMiddleware().Handle)

	handler.RegisterHandlers(server, ctx)

	fmt.Printf("Starting server at %s:%d...\n", c.Host, c.Port)
	server.Start()
}
```

# 2 使用goctl生成件相关的代码
```go
package middleware

import "net/http"

type TestMiddleware struct {
}

func NewTestMiddleware() *TestMiddleware {
	return &TestMiddleware{}
}

func (m *TestMiddleware) Handle(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO generate middleware implement function, delete after code implementation
        
		// Passthrough to next handler if need
		next(w, r)
	}
}
```
编写中间件相关逻辑,原来类似于java的AOP切面编程,链式调用。
原理是在路由注册的时候,引用了该中间件
```go
// Code generated by goctl. DO NOT EDIT.
package handler

import (
	"net/http"

	foo "zero-demo/user-api/internal/handler/foo"
	"zero-demo/user-api/internal/svc"

	"github.com/zeromicro/go-zero/rest"
)

func RegisterHandlers(server *rest.Server, serverCtx *svc.ServiceContext) {
	server.AddRoutes(
		rest.WithMiddlewares(
			[]rest.Middleware{serverCtx.TestMiddleware},
			[]rest.Route{
				{
					Method:  http.MethodPost,
					Path:    "/user/create",
					Handler: foo.UserCreateHandler(serverCtx),
				},
				{
					Method:  http.MethodPost,
					Path:    "/user/info",
					Handler: foo.UserInfoHandler(serverCtx),
				},
				{
					Method:  http.MethodPost,
					Path:    "/user/update",
					Handler: foo.UserUpdateHandler(serverCtx),
				},
			}...,
		),
		rest.WithPrefix("/userapi/v1"),
	)
}
```

# 3 在svc中申明和初始化
```go
package svc

import (
	"zero-demo/user-api/internal/config"
	"zero-demo/user-api/internal/middleware"

	"zero-demo/user-api/model"

	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/rest"
)

type ServiceContext struct {
	Config        config.Config
	UserModel     model.UserModel
	UserDataModel model.UserDataModel
	Middleware    rest.Middleware  // 包含中间件
}

func NewServiceContext(c config.Config) *ServiceContext {
	return &ServiceContext{
		Config:        c,
		UserModel:     model.NewUserModel(sqlx.NewMysql(c.DB.DataSource), c.Cache),
		UserDataModel: model.NewUserDataModel(sqlx.NewMysql(c.DB.DataSource), c.Cache),
		Middleware:    middleware.NewTestMiddleware().Handle,  // 初始化
	}
}
``` 




